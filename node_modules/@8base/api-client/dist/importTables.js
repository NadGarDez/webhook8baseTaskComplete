"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = __importStar(require("ramda"));
const error_codes_1 = __importDefault(require("@8base/error-codes"));
const constants_1 = require("./constants");
const handleError = (message, e, debug) => {
    // tslint:disable-next-line no-console
    console.warn(message);
    if (debug) {
        // tslint:disable-next-line no-console
        console.warn(JSON.stringify(e.response, null, 2));
    }
    else if (R.pathEq(['response', 'errors', 0, 'code'], error_codes_1.default.ValidationErrorCode, e)) {
        // tslint:disable-next-line no-console
        console.warn(JSON.stringify(R.path(['response', 'errors', 0, 'details'], e), null, 2));
    }
    else {
        // tslint:disable-next-line no-console
        console.warn(R.path(['response', 'errors', 0, 'message'], e));
    }
};
exports.importTables = (request, schema, options = {}) => __awaiter(this, void 0, void 0, function* () {
    const debug = R.propOr(false, 'debug', options);
    for (const table of schema) {
        try {
            yield request(constants_1.TABLE_CREATE_MUTATION, {
                data: {
                    displayName: table.displayName,
                    name: table.name,
                },
            });
        }
        catch (e) {
            handleError(`\nCan't create table "${table.name}"`, e, debug);
        }
    }
    const tablesListData = yield request(constants_1.TABLES_LIST_QUERY, {
        filter: {
            onlyUserTables: false,
        },
    });
    const tablesByName = R.indexBy(R.prop('name'), tablesListData.tablesList.items);
    for (const schemaTable of schema) {
        if (schemaTable.isSystem) {
            continue;
        }
        const table = tablesByName[schemaTable.name];
        for (const schemaField of schemaTable.fields) {
            if (schemaField.isSystem) {
                continue;
            }
            const field = R.pick([
                'name',
                'displayName',
                'fieldType',
                'isList',
                'isRequired',
                'isUnique',
                'defaultValue',
                'description',
                'fieldTypeAttributes',
                'relation',
                'tableId',
            ], schemaField);
            if (field.fieldTypeAttributes) {
                field.fieldTypeAttributes = R.pick([
                    'format',
                    'fieldSize',
                    'listOptions',
                    'precision',
                    'currency',
                    'minValue',
                    'maxValue',
                    'maxSize',
                    'typeRestrictions',
                    'isBigInt',
                ], field.fieldTypeAttributes);
            }
            if (field.relation) {
                const refTableName = field.relation.refTable.name;
                const refTable = tablesByName[refTableName];
                // @ts-ignore. Check what does do relations prop.
                if (refTable.relations && refTable.relations[schemaTable.name]) {
                    // @ts-ignore. Check what does do relations prop.
                    if (refTable.relations[schemaTable.name].includes(field.name)) {
                        continue;
                    }
                }
                field.relation = Object.assign({}, R.pick(['refFieldIsList', 'refFieldIsRequired', 'refFieldName', 'refFieldDisplayName'], field.relation), { refTableId: refTable.id });
                // @ts-ignore. Check what does relations prop do.
                table.relations = table.relations || {};
                // @ts-ignore. Check what does relations prop do.
                if (table.relations[refTableName]) {
                    // @ts-ignore. Check what does relations prop do.
                    table.relations[refTableName].push(field.relation.refFieldName);
                }
                else {
                    // @ts-ignore. Check what does relations prop do.
                    table.relations[refTableName] = [field.relation.refFieldName];
                }
            }
            // @ts-ignore. Check what does tableId prop do.
            field.tableId = table.id;
            try {
                yield request(constants_1.FIELD_CREATE_MUTATION, {
                    data: field,
                });
            }
            catch (e) {
                handleError(`\nCan't create field "${field.name}"`, e, debug);
            }
        }
    }
});
//# sourceMappingURL=importTables.js.map