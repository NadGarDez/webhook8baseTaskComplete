"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@8base/utils");
const schema_name_generator_1 = require("@8base/schema-name-generator");
const filestack = __importStar(require("filestack-js"));
const R = __importStar(require("ramda"));
const constants_1 = require("./constants");
const getRemoteEntityId = (localData, fieldSchema, $id, userId) => {
    let id = null;
    if ($id === '$currentUserId' && fieldSchema.relation.refTable.name === 'Users') {
        id = userId;
    }
    else {
        ({ id } = localData[fieldSchema.relation.refTable.name][$id]);
    }
    return id;
};
const MAX_THREADS = 5;
const uploadFiles = (record, tableSchema, filestackClient, path) => __awaiter(this, void 0, void 0, function* () {
    const fieldNames = R.keys(record);
    let nextRecord = record;
    for (let i = fieldNames.length - 1; i >= 0; i--) {
        const fieldName = fieldNames[i];
        const fieldSchema = utils_1.tableSelectors.getFieldByName(tableSchema, fieldName);
        if (fieldSchema && utils_1.tableFieldSelectors.isFileField(fieldSchema)) {
            if (utils_1.tableFieldSelectors.isListField(fieldSchema)) {
                if (Array.isArray(record[fieldName])) {
                    for (let j = 0; j < record[fieldName].length; j++) {
                        nextRecord = R.assocPath([fieldName, j, 'fileId'], (yield filestackClient.storeURL(record[fieldName][j].url, {
                            path,
                        })).handle, nextRecord);
                        nextRecord = R.dissocPath([fieldName, j, 'url'], nextRecord);
                    }
                }
            }
            else {
                if (record[fieldName]) {
                    nextRecord = R.assocPath([fieldName, 'fileId'], (yield filestackClient.storeURL(record[fieldName].url, {
                        path,
                    })).handle, nextRecord);
                    nextRecord = R.dissocPath([fieldName, 'url'], nextRecord);
                }
            }
        }
    }
    return nextRecord;
});
exports.importData = (request, schemaData, options = {}) => __awaiter(this, void 0, void 0, function* () {
    const { tablesList: { items: schema }, } = yield request(constants_1.TABLES_LIST_QUERY, {
        filter: {
            onlyUserTables: false,
        },
    });
    let fileUploadInfo = {};
    try {
        ({ fileUploadInfo } = yield request(constants_1.FILE_UPLOAD_INFO_QUERY));
    }
    catch (e) {
        // tslint:disable-next-line no-console
        console.log("Can't fetch file upload info", e);
    }
    const filestackClient = filestack.init(fileUploadInfo.apiKey, {
        security: {
            policy: fileUploadInfo.policy,
            signature: fileUploadInfo.signature,
        },
    });
    const localData = {};
    const maxThreads = R.propOr(MAX_THREADS, 'maxThreads', options);
    for (const tableName of Object.keys(schemaData)) {
        localData[tableName] = {};
        const tableSchema = utils_1.tablesListSelectors.getTableByName(schema, tableName);
        if (!tableSchema) {
            throw new utils_1.SDKError(utils_1.ERROR_CODES.TABLE_NOT_FOUND, utils_1.PACKAGES.API_CLIENT, `Table with name ${tableName} not found`);
        }
        for (let i = 0; i < schemaData[tableName].length / maxThreads; i++) {
            const tempData = schemaData[tableName].slice(i * maxThreads, (i + 1) * maxThreads);
            yield Promise.all(tempData.map((item) => __awaiter(this, void 0, void 0, function* () {
                item = yield uploadFiles(item, tableSchema, filestackClient, fileUploadInfo.path);
                const data = utils_1.formatDataForMutation(utils_1.MUTATION_TYPE.CREATE, item, {
                    tableName,
                    schema,
                }, {
                    skip: (value, fieldSchema) => utils_1.tableFieldSelectors.isRelationField(fieldSchema),
                });
                const fieldData = yield request(`
          mutation create($data: ${schema_name_generator_1.SchemaNameGenerator.getCreateInputName(tableName)}!) {
            field: ${schema_name_generator_1.SchemaNameGenerator.getCreateItemFieldName(tableName)}(data: $data) {
              id
            }
          }
        `, {
                    data,
                });
                if (item.$id) {
                    localData[tableName][item.$id] = fieldData.field;
                }
            })));
        }
    }
    let userId = '';
    try {
        const userData = yield request(constants_1.USER_QUERY);
        userId = userData.user.id;
    }
    catch (e) {
        // tslint:disable-next-line no-console
        console.log(`Can't fetch user info`, e);
    }
    for (const tableName of Object.keys(schemaData)) {
        for (const item of schemaData[tableName]) {
            const data = utils_1.formatDataForMutation(utils_1.MUTATION_TYPE.UPDATE, item, {
                tableName,
                schema,
            }, {
                mutate: (value, plainValue, fieldSchema) => {
                    if (Array.isArray(plainValue)) {
                        return {
                            connect: plainValue.map(({ $id }) => ({
                                id: getRemoteEntityId(localData, fieldSchema, $id, userId),
                            })),
                        };
                    }
                    if (!plainValue) {
                        return null;
                    }
                    const id = getRemoteEntityId(localData, fieldSchema, plainValue.$id, userId);
                    return { connect: { id } };
                },
                skip: (value, fieldSchema) => !utils_1.tableFieldSelectors.isRelationField(fieldSchema),
            });
            yield request(`
        mutation update($data: ${schema_name_generator_1.SchemaNameGenerator.getUpdateInputName(tableName)}!) {
          field: ${schema_name_generator_1.SchemaNameGenerator.getUpdateItemFieldName(tableName)}(data: $data) {
            id
          }
        }
      `, {
                data: Object.assign({}, data, { id: localData[tableName][item.$id].id }),
            });
        }
    }
});
//# sourceMappingURL=importData.js.map