"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const GraphqlActions_1 = require("../consts/GraphqlActions");
const utils_1 = require("./utils");
const AsyncStatus_1 = require("../consts/AsyncStatus");
const buildController_1 = require("../engine/controllers/buildController");
const Environment_1 = require("../consts/Environment");
exports.executeAsync = (context, query, variables = {}, options) => __awaiter(this, void 0, void 0, function* () {
    const { system: { async: { sessionId }, }, } = yield context.request(query, variables, options);
    let result;
    do {
        result = (yield context.request(GraphqlActions_1.GraphqlActions.asyncSessionStatus, { sessionId }, { customEnvironment: Environment_1.DEFAULT_ENVIRONMENT_NAME })).status;
        context.logger.debug(result);
        yield utils_1.Utils.sleep(2000);
        context.spinner.stop();
        context.spinner.start(context.i18n.t('async_in_progress', {
            status: result.status,
            message: result.message,
        }));
    } while (result.status !== AsyncStatus_1.AsyncStatus.completeSuccess && result.status !== AsyncStatus_1.AsyncStatus.completeError);
    context.spinner.stop();
    if (result.status === AsyncStatus_1.AsyncStatus.completeError) {
        let gqlError;
        try {
            gqlError = JSON.parse(result.message); // result.message contains valid gqlError, should be threw as is
        }
        catch (e) {
            throw new Error(result.message);
        }
        throw gqlError;
    }
    if (result.message) {
        context.logger.info(result.message);
    }
});
exports.uploadProject = (context, options) => __awaiter(this, void 0, void 0, function* () {
    const buildDir = yield buildController_1.BuildController.package(context);
    context.logger.debug(`build dir: ${buildDir}`);
    const { prepareDeploy } = yield context.request(GraphqlActions_1.GraphqlActions.prepareDeploy, {}, options);
    yield utils_1.Utils.upload(prepareDeploy.uploadBuildUrl, buildDir.build, context);
    context.logger.debug('upload source code complete');
    return { buildName: prepareDeploy.buildName };
});
exports.executeDeploy = (context, deployOptions, options) => __awaiter(this, void 0, void 0, function* () {
    context.spinner.start(context.i18n.t('deploy_in_progress', { status: 'prepare to upload' }));
    const buildDir = yield buildController_1.BuildController.package(context);
    context.logger.debug(`build dir: ${buildDir}`);
    const { prepareDeploy } = yield context.request(GraphqlActions_1.GraphqlActions.prepareDeploy, null, options);
    yield utils_1.Utils.upload(prepareDeploy.uploadMetaDataUrl, buildDir.meta, context);
    context.logger.debug('upload meta data complete');
    yield utils_1.Utils.upload(prepareDeploy.uploadBuildUrl, buildDir.build, context);
    context.logger.debug('upload source code complete');
    yield context.request(GraphqlActions_1.GraphqlActions.deploy, { data: { buildName: prepareDeploy.buildName, options: deployOptions } }, options);
    let result;
    do {
        result = (yield context.request(GraphqlActions_1.GraphqlActions.deployStatus, {
            buildName: prepareDeploy.buildName,
        })).deployStatus;
        context.logger.debug(result);
        yield utils_1.Utils.sleep(2000);
        context.spinner.stop();
        context.spinner.start(context.i18n.t('deploy_in_progress', {
            status: result.status,
            message: result.message,
        }));
    } while (result.status !== AsyncStatus_1.AsyncStatus.completeSuccess && result.status !== AsyncStatus_1.AsyncStatus.completeError);
    buildController_1.BuildController.clearBuild(context);
    context.spinner.stop();
    if (result.status === AsyncStatus_1.AsyncStatus.completeError) {
        let gqlError;
        try {
            gqlError = JSON.parse(result.message); // result.message contains valid gqlError, should be threw as is
        }
        catch (e) {
            throw new Error(result.message);
        }
        throw gqlError;
    }
});
//# sourceMappingURL=execute.js.map