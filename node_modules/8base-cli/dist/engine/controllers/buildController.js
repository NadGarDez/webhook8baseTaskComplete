"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const ignore_1 = require("ignore");
const recursiveReadDir = require("recursive-readdir");
const projectController_1 = require("./projectController");
const compilers_1 = require("../compilers");
const utils_1 = require("../../common/utils");
const IGNORE_FILE_PATH = './.8baseignore';
/*
  paths:
    /project_dir
      - user's files / folders
      - node_modules
      - .build
        - dist (use for local compile when invoke-local command is invoked
        - meta (use for build meta for project)
        - package (use for package command)
 */
class BuildController {
    static clearBuild(context) {
        fs.removeSync(context.config.buildRootDirPath);
    }
    /*
      Function workflow
        1. Clean up directory
        2. Create Metadata file
        3. Create Schema file and save it
        4. Archive build and summary
    */
    static package(context) {
        return __awaiter(this, void 0, void 0, function* () {
            BuildController.prepare(context);
            return {
                build: yield BuildController.packageSources(context),
                meta: yield BuildController.packageMetadata(context),
            };
        });
    }
    // compile use only for invoke-local command
    static compile(context) {
        return __awaiter(this, void 0, void 0, function* () {
            BuildController.prepare(context);
            const files = projectController_1.ProjectController.getFunctionSourceCode(context);
            context.logger.debug('resolve compilers');
            const compiler = compilers_1.getCompiler(files, context);
            const compiledFiles = yield compiler.compile(context.config.buildDistPath);
            context.logger.debug('compiled files = ' + compiledFiles);
            return {
                compiledFiles,
            };
        });
    }
    /**
     * Private functions
     */
    static packageSources(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const excludedDirectories = ['.git', '.idea'];
            const excludedRoots = [
                context.config.buildRootFolder,
                context.config.buildDistFolder,
                context.config.modulesFolder,
                context.config.metaFolder,
                context.config.packageFolder,
            ];
            // have to add '/' at the beginning to ignore only root folder. avoid recursive
            const ignoreFilter = ignore_1.default().add(excludedRoots.map(item => '/' + item));
            if (fs.existsSync(IGNORE_FILE_PATH)) {
                ignoreFilter.add(fs.readFileSync(IGNORE_FILE_PATH).toString());
            }
            const files = yield recursiveReadDir(context.config.rootExecutionDir, excludedDirectories);
            const sourceToArchive = files
                .map(file => path.relative(process.cwd(), file))
                .filter(file => !ignoreFilter.ignores(file))
                .map(file => ({ dist: file, source: file }));
            return utils_1.Utils.archiveToMemory(sourceToArchive, context);
        });
    }
    static packageMetadata(context) {
        const metaDir = context.config.metaDir;
        projectController_1.ProjectController.saveMetaDataFile(context.project, metaDir);
        projectController_1.ProjectController.saveSchema(context.project, metaDir);
        projectController_1.ProjectController.saveProject(context.project, metaDir);
        return utils_1.Utils.archiveToMemory([{ source: metaDir }], context);
    }
    static prepare(context) {
        fs.removeSync(context.config.buildRootDirPath);
        fs.mkdirpSync(context.config.buildDistPath);
        fs.mkdirpSync(context.config.metaDir);
        fs.mkdirpSync(context.config.packageDir);
    }
}
exports.BuildController = BuildController;
//# sourceMappingURL=buildController.js.map