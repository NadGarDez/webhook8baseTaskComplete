"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");
const ejs = require("ejs");
const mkdirp = require("mkdirp");
const changeCase = require("change-case");
const _ = require("lodash");
const config_1 = require("../../config");
const errors_1 = require("../../errors");
const graphqlController_1 = require("../../engine/controllers/graphqlController");
const Extensions_1 = require("../../interfaces/Extensions");
const generateFunctionDeclaration = ({ type, name, mocks, syntax }, dirPath, options) => {
    let declaration = {
        type,
        handler: {
            code: `${dirPath}/handler.${syntax}`,
        },
    };
    if (type === Extensions_1.ExtensionType.resolver) {
        declaration = _.merge(declaration, {
            schema: `${dirPath}/schema.graphql`,
        });
    }
    else if (type === Extensions_1.ExtensionType.task && options.schedule) {
        declaration = _.merge(declaration, {
            schedule: options.schedule,
        });
    }
    else if (type === Extensions_1.ExtensionType.trigger) {
        declaration = _.merge(declaration, {
            type: `trigger.${options.type || 'before'}`,
            operation: options.operation || 'Users.create',
        });
    }
    else if (type === Extensions_1.ExtensionType.webhook) {
        declaration = _.merge(declaration, {
            path: options.path || '/webhook',
            method: options.method || 'POST',
        });
    }
    return declaration;
};
class ProjectController {
    /**
     * public functions
     */
    static initialize(context) {
        const name = path.basename(context.config.rootExecutionDir);
        context.logger.debug('start initialize project "' + name + '"');
        context.logger.debug('load main yml file');
        const config = ProjectController.loadConfigFile(context);
        context.logger.debug('load extensions');
        const extensions = ProjectController.loadExtensions(config);
        const gqlSchema = graphqlController_1.GraphqlController.loadSchema(ProjectController.getSchemaPaths(extensions));
        context.logger.debug('load functions count = ' + extensions.functions.length);
        context.logger.debug('resolve function graphql types');
        const functionGqlTypes = graphqlController_1.GraphqlController.defineGqlFunctionsType(gqlSchema);
        extensions.resolvers = ResolverUtils.resolveGqlFunctionTypes(extensions.resolvers, functionGqlTypes);
        context.logger.debug('initialize project complete');
        return {
            extensions,
            name,
            gqlSchema,
        };
    }
    static getFunctionSourceCode(context) {
        return _.map(context.project.extensions.functions, f => path.join(context.config.rootExecutionDir, f.pathToFunction));
    }
    static saveSchema(project, outDir) {
        const graphqlFilePath = path.join(outDir, 'schema.graphql');
        fs.writeFileSync(graphqlFilePath, project.gqlSchema);
    }
    static saveProject(project, outDir) {
        const projectObject = {
            name: project.name,
            functions: project.extensions.functions,
        };
        const projectFilePath = path.join(outDir, 'project.json');
        return fs.writeFileSync(projectFilePath, JSON.stringify(projectObject, null, 2));
    }
    static saveMetaDataFile(project, outDir) {
        const summaryFile = path.join(outDir, '__summary__functions.json');
        fs.writeFileSync(summaryFile, JSON.stringify({
            functions: project.extensions.functions.map(f => {
                return {
                    name: f.name,
                    handler: f.handler,
                };
            }),
            resolvers: project.extensions.resolvers.map(r => {
                return {
                    name: r.name,
                    functionName: r.functionName,
                    gqlType: r.gqlType,
                };
            }),
            triggers: project.extensions.triggers,
            webhooks: project.extensions.webhooks,
        }, null, 2));
    }
    static getSchemaPaths(extensions) {
        return _.map(extensions.resolvers, f => {
            const p = path.join(config_1.StaticConfig.rootExecutionDir, f.gqlSchemaPath);
            if (!fs.existsSync(p)) {
                throw new Error('schema path "' + p + '" not present');
            }
            return p;
        });
    }
    /**
     * private functions
     */
    static loadConfigFile(context, projectPath) {
        const pathToYmlConfig = projectPath ? path.join(projectPath, '8base.yml') : config_1.StaticConfig.serviceConfigFileName;
        context.logger.debug('check exist yaml file = ' + pathToYmlConfig);
        if (!fs.existsSync(pathToYmlConfig)) {
            throw new Error(context.i18n.t('8base_config_is_missing'));
        }
        try {
            return yaml.safeLoad(fs.readFileSync(pathToYmlConfig, 'utf8'));
        }
        catch (ex) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, ex.message);
        }
    }
    static saveConfigFile(context, config, projectPath, silent) {
        const pathToYmlConfig = projectPath ? path.join(projectPath, '8base.yml') : config_1.StaticConfig.serviceConfigFileName;
        fs.writeFileSync(pathToYmlConfig, yaml.safeDump(config));
        if (!silent) {
            context.logger.info(context.i18n.t('project_updated_file', {
                path: pathToYmlConfig,
            }));
        }
    }
    static loadExtensions(config) {
        return _.reduce(config.functions, (extensions, data, functionName) => {
            FunctionUtils.validateFunctionDefinition(data, functionName);
            extensions.functions.push({
                name: functionName,
                // TODO: create class FunctionDefinition
                handler: functionName + '.handler',
                pathToFunction: FunctionUtils.resolveHandler(functionName, data.handler),
            });
            switch (FunctionUtils.resolveFunctionType(data.type, functionName)) {
                case Extensions_1.ExtensionType.resolver:
                    extensions.resolvers.push({
                        name: functionName,
                        functionName: functionName,
                        gqlSchemaPath: data.schema,
                        gqlType: undefined,
                    });
                    break;
                case Extensions_1.ExtensionType.task:
                    extensions.tasks.push({
                        name: functionName,
                        functionName: functionName,
                    });
                    break;
                case Extensions_1.ExtensionType.trigger:
                    if (_.isNil(data.operation)) {
                        throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'operation field not present in trigger ' + functionName);
                    }
                    const operation = data.operation.split('.'); // TableName.TriggerType
                    extensions.triggers.push({
                        name: functionName,
                        operation: TriggerUtils.resolveTriggerOperation(operation[1], functionName),
                        tableName: operation[0],
                        functionName,
                        type: TriggerUtils.resolveTriggerType(data.type, functionName),
                    });
                    break;
                case Extensions_1.ExtensionType.webhook:
                    if (!data.method) {
                        throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, "Parameter 'method' is missing in webhook '" + functionName + "'");
                    }
                    extensions.webhooks.push({
                        name: functionName,
                        functionName,
                        httpMethod: data.method,
                        path: data.path ? data.path : functionName,
                    });
                    break;
                default:
                    break;
            }
            if (data.schedule) {
                extensions.schedules.push({
                    name: functionName,
                    functionName,
                    scheduleExpression: data.schedule,
                });
            }
            return extensions;
        }, {
            resolvers: [],
            tasks: [],
            functions: [],
            webhooks: [],
            triggers: [],
            schedules: [],
        });
    }
    static addPluginDeclaration(context, name, declaration, projectPath, silent) {
        let config = ProjectController.loadConfigFile(context, projectPath);
        const plugins = config.plugins || [];
        if (_.some(plugins, { name })) {
            throw new Error(context.i18n.t('plugins_with_name_already_defined', { name }));
        }
        config.plugins = [...plugins, declaration];
        ProjectController.saveConfigFile(context, config, projectPath, silent);
    }
    static addFunctionDeclaration(context, name, declaration, projectPath, silent) {
        let config = ProjectController.loadConfigFile(context, projectPath) || {
            functions: {},
        };
        if (_.has(config, ['functions', name])) {
            throw new Error(context.i18n.t('function_with_name_already_defined', { name }));
        }
        config = _.set(config, ['functions', name], declaration);
        ProjectController.saveConfigFile(context, config, projectPath, silent);
    }
    static generateFunction(context, { type, name, mocks, syntax, extendType = 'Query', projectPath = '.', silent }, options = {}) {
        const dirPath = `src/${type}s/${name}`;
        ProjectController.addFunctionDeclaration(context, name, generateFunctionDeclaration({ type, name, syntax, mocks }, dirPath, options), projectPath, silent);
        const functionTemplatePath = path.resolve(context.config.functionTemplatesPath, type);
        processTemplate(context, {
            dirPath: path.join(projectPath, dirPath),
            templatePath: functionTemplatePath,
        }, { syntax, mocks, silent }, { functionName: name, type, extendType });
        if (!silent) {
            context.logger.info('');
            context.logger.info(context.i18n.t('generate_function_grettings', {
                name,
            }));
        }
    }
    static generatePlugin(context, { name, syntax, silent, projectPath = '.' }) {
        const functionName = `${name}Resolver`;
        const extendType = _.upperFirst(`${name}Mutation`);
        const pluginPath = path.join('plugins', name);
        const functionPath = path.join(pluginPath, 'src', 'resolvers', functionName);
        const pluginTemplatePath = context.config.pluginTemplatePath;
        const resolverTemplatePath = path.resolve(context.config.functionTemplatesPath, Extensions_1.ExtensionType.resolver);
        ProjectController.addPluginDeclaration(context, name, {
            name,
            path: path.join(pluginPath, '8base.yml'),
        }, projectPath, silent);
        processTemplate(context, {
            dirPath: path.join(projectPath, pluginPath),
            templatePath: pluginTemplatePath,
        }, { syntax, silent }, { name, syntax, functionName });
        processTemplate(context, {
            dirPath: path.join(projectPath, functionPath),
            templatePath: resolverTemplatePath,
        }, { syntax, mocks: false, silent }, { functionName, type: Extensions_1.ExtensionType.resolver, extendType });
        if (!silent) {
            context.logger.info('');
            context.logger.info(context.i18n.t('generate_plugin_grettings', {
                name,
            }));
        }
    }
    static getMock(context, functionName, mockName) {
        let config = ProjectController.loadConfigFile(context, '.') || {
            functions: {},
        };
        if (!_.has(config, ['functions', functionName])) {
            throw new Error(context.i18n.t('function_with_name_not_defined', { name: functionName }));
        }
        const type = _.get(config, ['functions', functionName]).type.match(/^\w+/)[0];
        const mockPath = `src/${type}s/${functionName}/mocks/${mockName}.json`;
        if (!fs.existsSync(mockPath)) {
            throw new Error(context.i18n.t('mock_with_name_not_defined', { functionName, mockName }));
        }
        return fs.readFileSync(mockPath).toString();
    }
    static generateMock(context, { name, functionName, projectPath = '.', silent }) {
        let config = ProjectController.loadConfigFile(context, projectPath) || {
            functions: {},
        };
        if (!_.has(config, ['functions', functionName])) {
            throw new Error(context.i18n.t('function_with_name_not_defined', { name: functionName }));
        }
        const fn = _.get(config, ['functions', functionName]);
        const type = fn.type.match(/^\w+/)[0];
        const mockPath = `src/${type}s/${functionName}/mocks/${name}.json`;
        if (fs.existsSync(mockPath)) {
            throw new Error(context.i18n.t('mock_with_name_already_defined', {
                mockName: name,
                functionName,
            }));
        }
        const dirPath = `src/${type}s/${functionName}/mocks`;
        processTemplate(context, {
            dirPath: path.join(projectPath, dirPath),
            templatePath: context.config.mockTemplatePath,
        }, { silent }, { mockName: name });
        if (!silent) {
            context.logger.info('');
            context.logger.info(context.i18n.t('generate_mock_grettings', {
                name,
            }));
        }
    }
}
exports.ProjectController = ProjectController;
const processTemplate = (context, { dirPath, templatePath }, { syntax, silent, mocks }, options) => {
    mkdirp.sync(dirPath);
    fs.readdirSync(templatePath).forEach(file => {
        if (file.indexOf('.') === -1) {
            if (file !== 'mocks' || mocks) {
                processTemplate(context, {
                    dirPath: path.join(dirPath, file),
                    templatePath: path.join(templatePath, file),
                }, {
                    syntax,
                    silent,
                    mocks,
                }, options);
            }
            return;
        }
        if (new RegExp(`.${syntax === Extensions_1.SyntaxType.js ? Extensions_1.SyntaxType.ts : Extensions_1.SyntaxType.js}.ejs$`).test(file)) {
            return;
        }
        const data = fs.readFileSync(path.resolve(templatePath, file));
        const content = ejs.compile(data.toString())(Object.assign({}, options, { changeCase }));
        let fileName = file.replace(/\.ejs$/, '');
        fileName = fileName.replace('mockName', _.get(options, 'mockName'));
        fs.writeFileSync(path.resolve(dirPath, fileName), content);
        if (!silent) {
            context.logger.info(context.i18n.t('project_created_file', {
                path: path.join(dirPath, fileName),
            }));
        }
    });
};
var ResolverUtils;
(function (ResolverUtils) {
    /**
     * @argument types project, { functionName: type }
     * Function resolve graphql type for each function.
     * we have to know function type (mutation, query) for compile schema on the server side
     */
    function resolveGqlFunctionTypes(resolvers, types) {
        resolvers.forEach(func => {
            const type = types[func.name];
            if (_.isNil(type)) {
                throw new Error('Cannot define graphql type for function "' + func.name + '"');
            }
            func.gqlType = type;
        });
        return resolvers;
    }
    ResolverUtils.resolveGqlFunctionTypes = resolveGqlFunctionTypes;
})(ResolverUtils || (ResolverUtils = {}));
var FunctionUtils;
(function (FunctionUtils) {
    function resolveHandler(name, handler) {
        if (_.isString(handler.code)) {
            return handler.code;
        }
        throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'handler is invalid for function "' + name + '"');
    }
    FunctionUtils.resolveHandler = resolveHandler;
    function validateFunctionDefinition(func, name) {
        if (_.isNil(func.handler)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'handler is absent for function "' + name + '"');
        }
        if (func.handler.code && !fs.existsSync(path.join(config_1.StaticConfig.rootExecutionDir, func.handler.code))) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'unable to determine function "' + name + '" source code');
        }
        if (!config_1.StaticConfig.supportedCompileExtension.has(path.extname(func.handler.code))) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'function "' + name + '" have unsupported file extension');
        }
    }
    FunctionUtils.validateFunctionDefinition = validateFunctionDefinition;
    /**
     *
     * @param type "resolve", "trigger.before", "trigger.after", "subscription", "webhook"
     * @return FunctionType
     */
    function resolveFunctionType(type, functionName) {
        const funcType = type.split('.')[0];
        const resolvedType = Extensions_1.ExtensionType[funcType];
        if (_.isNil(resolvedType)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'Invalid function type ' + type + ' in function ' + functionName);
        }
        return resolvedType;
    }
    FunctionUtils.resolveFunctionType = resolveFunctionType;
})(FunctionUtils || (FunctionUtils = {}));
var TriggerUtils;
(function (TriggerUtils) {
    function resolveTriggerOperation(operation, funcName) {
        const resolvedOperation = Extensions_1.TriggerOperation[operation];
        if (_.isNil(resolvedOperation)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'Invalid trigger operation ' + operation + ' in function ' + funcName);
        }
        return resolvedOperation;
    }
    TriggerUtils.resolveTriggerOperation = resolveTriggerOperation;
    /**
     *
     * @param type "resolve", "trigger.before", "trigger.after", "subscription"
     * @return TriggerStageType
     */
    function resolveTriggerType(type, functionName) {
        const triggerType = type.split('.')[1];
        const resolvedType = Extensions_1.TriggerType[triggerType];
        if (_.isNil(resolvedType)) {
            throw new errors_1.InvalidConfiguration(config_1.StaticConfig.serviceConfigFileName, 'Invalid trigger type ' + type + ' in function ' + functionName);
        }
        return resolvedType;
    }
    TriggerUtils.resolveTriggerType = resolveTriggerType;
})(TriggerUtils || (TriggerUtils = {}));
//# sourceMappingURL=projectController.js.map