"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const error_codes_1 = require("@8base/error-codes");
const _ = require("lodash");
const context_1 = require("../../common/context");
const Colors_1 = require("../../consts/Colors");
const NON_PROJECT_COMMANDS = [
    'init',
    'login',
    'logout',
    'configure',
    'plugin list',
    'p list',
    'whoami',
    'environment list',
];
const ERROR_CODES_TO_PRINT_MESSAGES = [error_codes_1.default.BillingFeatureAccessErrorCode];
const hasWorkspaceNotFoundError = (response) => {
    const errors = _.get(response, 'errors', []);
    return _.some(errors, { code: error_codes_1.default.EntityNotFoundErrorCode, details: { workspaceId: 'Workspace not found' } });
};
class CommandController {
}
CommandController.parseError = (error) => {
    if (error.response &&
        error.response.errors &&
        error.response.errors.length > 0 &&
        error.response.errors[0].message) {
        const internalError = error.response.errors[0];
        if (ERROR_CODES_TO_PRINT_MESSAGES.some(m => m === internalError.code)) {
            return internalError.message;
        }
        if (internalError.details) {
            const keys = Object.keys(internalError.details);
            if (keys.length > 0) {
                return internalError.details[keys[0]];
            }
        }
        return internalError.message;
    }
    return error.message;
};
CommandController.wrapHandler = (handler, translations) => {
    return (params) => __awaiter(this, void 0, void 0, function* () {
        const command = params._[0];
        const context = new context_1.Context(params, translations);
        const start = Date.now();
        try {
            if (NON_PROJECT_COMMANDS.indexOf(command) === -1 && NON_PROJECT_COMMANDS.indexOf(params._.join(' ')) === -1) {
                if (!context.isProjectDir()) {
                    throw new Error(translations.i18n.t('non_8base_project_dir'));
                }
            }
            yield handler(params, context);
            context.spinner.stop();
            const time = Date.now() - start;
            context.logger.info(`${chalk_1.default.hex(Colors_1.Colors.green)(command)} done. Time: ${chalk_1.default.hex(Colors_1.Colors.green)(time.toLocaleString('en-US'))} ms.`);
        }
        catch (ex) {
            context.spinner.stop();
            if (hasWorkspaceNotFoundError(_.get(ex, 'response', {}))) {
                context.logger.error(translations.i18n.t('workspace_not_found'));
            }
            else {
                context.logger.error(`${CommandController.parseError(ex)}`);
            }
            const time = Date.now() - start;
            context.logger.error(`Time: ${chalk_1.default.hex(Colors_1.Colors.red)(time.toLocaleString('en-US'))} ms.`);
            process.exit(1);
        }
    });
};
exports.CommandController = CommandController;
//# sourceMappingURL=commandController.js.map