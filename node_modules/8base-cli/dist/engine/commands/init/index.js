"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const path = require("path");
const fs = require("fs");
const chalk_1 = require("chalk");
const tree = require("tree-node-cli");
const validatePackageName = require("validate-npm-package-name");
const providers_1 = require("./providers");
const installer_1 = require("./installer");
const translations_1 = require("../../../common/translations");
const Colors_1 = require("../../../consts/Colors");
const projectController_1 = require("../../controllers/projectController");
const Extensions_1 = require("../../../interfaces/Extensions");
const interactive_1 = require("../../../common/interactive");
const Environment_1 = require("../../../consts/Environment");
const CREATE_WORKSPACE_MUTATION = `
  mutation WorkspaceCreate($data: WorkspaceCreateMutationInput!) {
    workspaceCreate(data: $data) {
      id
    }
  }
`;
const isEmptyDir = (path) => {
    let files = [];
    try {
        files = fs.readdirSync(path);
    }
    catch (e) { }
    return files.length === 0;
};
exports.default = {
    command: 'init',
    handler: (params, context) => __awaiter(this, void 0, void 0, function* () {
        const { functions, empty, syntax, mocks, silent } = params;
        let { workspaceId, host } = params;
        const [, projectName] = _.castArray(params._);
        const { errors = [] } = validatePackageName(projectName);
        if (errors.length > 0) {
            throw new Error(translations_1.translations.i18n.t('init_invalid_project_name', {
                validationMessages: errors.join(', '),
            }));
        }
        const project = projectName
            ? {
                fullPath: path.join(context.config.rootExecutionDir, projectName),
                name: projectName,
            }
            : {
                fullPath: context.config.rootExecutionDir,
                name: path.basename(context.config.rootExecutionDir),
            };
        if (!isEmptyDir(project.fullPath)) {
            const { confirm } = yield interactive_1.Interactive.ask({
                name: 'confirm',
                type: 'confirm',
                message: translations_1.translations.i18n.t('init_confirm_not_empty_dir'),
                initial: false,
            });
            if (!confirm) {
                throw new Error(translations_1.translations.i18n.t('init_canceled'));
            }
        }
        if (!empty && Array.isArray(functions)) {
            functions.forEach(declaration => {
                const [type, name] = declaration.split(':');
                if (!(type in Extensions_1.ExtensionType)) {
                    throw new Error(translations_1.translations.i18n.t('init_invalid_function_type', { type }));
                }
                if (!name) {
                    throw new Error(translations_1.translations.i18n.t('init_undefined_function_name'));
                }
            });
        }
        if (!workspaceId) {
            const workspaces = yield context.getWorkspaces();
            ({ workspaceId } = yield interactive_1.Interactive.ask({
                name: 'workspaceId',
                type: 'select',
                message: translations_1.translations.i18n.t('init_select_workspace'),
                choices: [
                    {
                        title: '<New Workspace>',
                        value: 'NEW_WORKSPACE',
                    },
                    ...workspaces.map((workspace) => ({
                        title: workspace.name,
                        value: workspace.id,
                    })),
                ],
            }));
            if (workspaceId === 'NEW_WORKSPACE') {
                const { workspaceName } = yield interactive_1.Interactive.ask({
                    name: 'workspaceName',
                    type: 'text',
                    message: translations_1.translations.i18n.t('init_workspace_name_labal'),
                });
                if (!workspaceName) {
                    throw new Error(translations_1.translations.i18n.t('init_prevent_new_workspace'));
                }
                else {
                    const { workspaceCreate } = yield context.request(CREATE_WORKSPACE_MUTATION, {
                        data: {
                            name: workspaceName,
                        },
                    });
                    workspaceId = workspaceCreate.id;
                }
            }
            if (!workspaceId) {
                throw new Error(translations_1.translations.i18n.t('init_prevent_select_workspace'));
            }
            const workspace = _.find(yield context.getWorkspaces(), { id: workspaceId });
            if (!workspace) {
                throw new Error(context.i18n.t('workspace_with_id_doesnt_exist', { id: workspaceId }));
            }
            host = workspace.apiHost;
        }
        context.spinner.start(`Initializing new project ${chalk_1.default.hex(Colors_1.Colors.yellow)(project.name)}`);
        context.logger.debug('start initialize init command');
        context.logger.debug(`initialize success: initialize repository: ${project.name}`);
        let files = yield providers_1.getFileProvider().provide(context);
        context.logger.debug('files provided count = ' + files.size);
        files.set(context.config.packageFileName, replaceServiceName(files.get(context.config.packageFileName), project.name));
        context.logger.debug('try to install files');
        installer_1.install(project.fullPath, files, context);
        context.spinner.stop();
        /* Creating new project message */
        const chalkedName = chalk_1.default.hex(Colors_1.Colors.yellow)(project.name);
        if (!silent) {
            context.logger.info(`Building a new project called ${chalkedName} ðŸš€`);
        }
        /* Generate project files before printing tree */
        if (!empty && Array.isArray(params.functions)) {
            params.functions.forEach((declaration) => {
                const [type, name] = declaration.split(':');
                projectController_1.ProjectController.generateFunction(context, {
                    type: type,
                    name,
                    mocks,
                    syntax,
                    projectPath: projectName,
                    silent: true,
                });
            });
        }
        context.createWorkspaceConfig({
            workspaceId,
            environmentName: Environment_1.DEFAULT_ENVIRONMENT_NAME,
            apiHost: host || Environment_1.DEFAULT_REMOTE_ADDRESS,
        }, project.fullPath);
        if (!silent) {
            // @ts-ignore
            const fileTree = tree(project.fullPath, {
                allFiles: true,
                exclude: [/node_modules/, /\.build/],
            });
            /* Print out tree of new project */
            context.logger.info(project.name);
            context.logger.info(fileTree.replace(/[^\n]+\n/, ''));
            /* Print project created message */
            context.logger.info(`ðŸŽ‰ Project ${chalkedName} was successfully created ðŸŽ‰`);
        }
    }),
    describe: translations_1.translations.i18n.t('init_describe'),
    builder: (args) => {
        return args
            .usage(translations_1.translations.i18n.t('init_usage'))
            .option('functions', {
            alias: 'f',
            describe: translations_1.translations.i18n.t('init_functions_describe'),
            type: 'array',
            default: ['resolver:resolver', 'task:task', 'webhook:webhook', 'trigger:trigger'],
        })
            .option('empty', {
            alias: 'e',
            describe: translations_1.translations.i18n.t('init_empty_describe'),
            default: false,
            type: 'boolean',
        })
            .option('mocks', {
            alias: 'x',
            describe: translations_1.translations.i18n.t('generate_mocks_describe'),
            default: true,
            type: 'boolean',
        })
            .option('syntax', {
            alias: 's',
            describe: translations_1.translations.i18n.t('generate_syntax_describe'),
            default: 'ts',
            type: 'string',
            choices: Object.values(Extensions_1.SyntaxType),
        })
            .option('silent', {
            describe: translations_1.translations.i18n.t('silent_describe'),
            default: false,
            type: 'boolean',
        })
            .option('workspaceId', {
            alias: 'w',
            describe: translations_1.translations.i18n.t('init_workspace_id_describe'),
            type: 'string',
        })
            .option('host', {
            describe: translations_1.translations.i18n.t('init_workspace_host_describe'),
            type: 'string',
            default: Environment_1.DEFAULT_REMOTE_ADDRESS,
        })
            .example(translations_1.translations.i18n.t('init_no_dir_example_command'), translations_1.translations.i18n.t('init_example_no_dir'))
            .example(translations_1.translations.i18n.t('init_with_dir_example_command'), translations_1.translations.i18n.t('init_example_with_dir'));
    },
};
const replaceServiceName = (packageFile, repositoryName) => {
    let packageData = JSON.parse(packageFile);
    packageData.name = repositoryName;
    return JSON.stringify(packageData, null, 2);
};
//# sourceMappingURL=index.js.map